---

## Quick Reference: Kotlin for DSA
*20-Minute Revision Guide*

### Essential Syntax

```kotlin
// Variables
val immutable = 10              // Read-only
var mutable = 20                // Mutable
const val CONSTANT = 100        // Compile-time constant

// Functions
fun add(a: Int, b: Int): Int = a + b
fun greet(name: String = "Guest") = "Hello, $name"

// Loops
for (i in 0..10) { }           // 0 to 10 inclusive
for (i in 0 until 10) { }      // 0 to 9
for (i in 10 downTo 0) { }     // 10 to 0
for (i in 0..10 step 2) { }    // 0, 2, 4, 6, 8, 10
repeat(5) { }                  // Execute 5 times

// Conditions
val max = if (a > b) a else b
when (x) {
    in 1..10 -> println("1-10")
    else -> println("Other")
}
```

---

### Collections Cheat Sheet

#### Array Operations

```kotlin
// Creation
val arr = arrayOf(1, 2, 3, 4, 5)
val intArr = intArrayOf(1, 2, 3)
val arr2D = Array(n) { IntArray(m) }

// Access
arr[0]                          // Get
arr[0] = 10                     // Set
arr.size                        // Length
arr.indices                     // 0 until size
arr.lastIndex                   // size - 1

// Common operations
arr.sort()                      // In-place sort
val sorted = arr.sorted()       // New sorted list
arr.reverse()                   // In-place reverse
arr.sum()                       // Sum of elements
arr.max()                       // Maximum
arr.min()                       // Minimum
arr.average()                   // Average
```

#### List Operations

```kotlin
// Creation
val list = listOf(1, 2, 3)              // Immutable
val mutableList = mutableListOf(1, 2, 3) // Mutable

// Add/Remove (MutableList only)
mutableList.add(4)                      // Add to end
mutableList.add(0, 5)                   // Add at index
mutableList.remove(3)                   // Remove element
mutableList.removeAt(0)                 // Remove at index
mutableList.clear()                     // Remove all

// Access
list[0]                                 // Get
list.first()                            // First element
list.last()                             // Last element
list.getOrNull(10)                      // Safe get

// Search
list.indexOf(3)                         // Index of element (-1 if not found)
list.contains(3)                        // Check existence
3 in list                               // Same as contains
list.binarySearch(3)                    // Binary search (must be sorted)

// Sublist
list.subList(1, 3)                      // Elements from index 1 to 2
list.take(3)                            // First 3 elements
list.drop(2)                            // Skip first 2 elements
list.slice(1..3)                        // Elements at indices 1, 2, 3
```

#### Common Collection Functions

```kotlin
val numbers = listOf(1, 2, 3, 4, 5, 6)

// Transform
numbers.map { it * 2 }                  // [2, 4, 6, 8, 10, 12]
numbers.filter { it % 2 == 0 }          // [2, 4, 6]
numbers.filterIndexed { i, v -> i % 2 == 0 }

// Aggregate
numbers.sum()                           // 21
numbers.count()                         // 6
numbers.count { it > 3 }                // 3
numbers.maxOrNull()                     // 6
numbers.minOrNull()                     // 1
numbers.average()                       // 3.5
numbers.reduce { acc, n -> acc + n }    // 21
numbers.fold(10) { acc, n -> acc + n }  // 31

// Search
numbers.find { it > 3 }                 // 4 (first match)
numbers.findLast { it > 3 }             // 6 (last match)
numbers.any { it > 5 }                  // true
numbers.all { it > 0 }                  // true
numbers.none { it < 0 }                 // true

// Group
numbers.groupBy { it % 2 }              // {1=[1,3,5], 0=[2,4,6]}
numbers.partition { it % 2 == 0 }       // Pair([2,4,6], [1,3,5])
numbers.chunked(2)                      // [[1,2], [3,4], [5,6]]
numbers.windowed(3)                     // [[1,2,3], [2,3,4], [3,4,5], [4,5,6]]

// Other
numbers.distinct()                      // Remove duplicates
numbers.sorted()                        // Sort ascending
numbers.sortedDescending()              // Sort descending
numbers.reversed()                      // Reverse
numbers.shuffled()                      // Random order
numbers.zip(listOf("a", "b"))           // [(1,a), (2,b)]
listOf(listOf(1, 2), listOf(3)).flatten() // [1, 2, 3]
```

#### Map Operations

```kotlin
// Creation
val map = mapOf("a" to 1, "b" to 2)
val mutableMap = mutableMapOf<String, Int>()

// Add/Update
mutableMap["c"] = 3                     // Put
mutableMap.put("d", 4)                  // Put (returns old value)
mutableMap.putIfAbsent("e", 5)          // Only if key absent

// Access
map["a"]                                // Get (returns null if absent)
map.getValue("a")                       // Get (throws if absent)
map.getOrDefault("z", 0)                // Get with default
map.getOrElse("z") { 0 }                // Get with lambda default

// Remove
mutableMap.remove("a")                  // Remove by key
mutableMap.clear()                      // Remove all

// Iterate
for ((key, value) in map) {
    println("$key -> $value")
}
map.forEach { (k, v) -> println("$k -> $v") }

// Keys/Values
map.keys                                // Set of keys
map.values                              // Collection of values
map.entries                             // Set of entries

// Check
map.containsKey("a")                    // Check key
map.containsValue(1)                    // Check value
"a" in map                              // Same as containsKey
```

#### Set Operations

```kotlin
// Creation
val set = setOf(1, 2, 3, 2)             // [1, 2, 3] - no duplicates
val mutableSet = mutableSetOf<Int>()

// Add/Remove
mutableSet.add(1)                       // Add element
mutableSet.remove(1)                    // Remove element
mutableSet.addAll(listOf(2, 3))         // Add multiple

// Operations
val set1 = setOf(1, 2, 3)
val set2 = setOf(3, 4, 5)

set1.union(set2)                        // [1, 2, 3, 4, 5]
set1.intersect(set2)                    // [3]
set1.subtract(set2)                     // [1, 2]
```

---

### String Operations

```kotlin
// Creation
val str = "Hello World"
val multiline = """
    Line 1
    Line 2
""".trimIndent()

// Access
str[0]                                  // 'H'
str.first()                             // 'H'
str.last()                              // 'd'
str.length                              // 11

// Substring
str.substring(0, 5)                     // "Hello"
str.take(5)                             // "Hello"
str.drop(6)                             // "World"
str.slice(0..4)                         // "Hello"

// Search
str.indexOf("World")                    // 6
str.contains("World")                   // true
"World" in str                          // true
str.startsWith("Hello")                 // true
str.endsWith("World")                   // true

// Transform
str.uppercase()                         // "HELLO WORLD"
str.lowercase()                         // "hello world"
str.capitalize()                        // "Hello World" (deprecated)
str.replaceFirstChar { it.uppercase() } // "Hello World"
str.replace("World", "Kotlin")          // "Hello Kotlin"
str.trim()                              // Remove whitespace
str.split(" ")                          // ["Hello", "World"]
str.reversed()                          // "dlroW olleH"

// Check
str.isEmpty()                           // false
str.isNotEmpty()                        // true
str.isBlank()                           // false (has non-whitespace)
str.all { it.isLetter() }               // false (has space)
str.any { it.isDigit() }                // false

// Convert
str.toIntOrNull()                       // null (not a number)
"123".toInt()                           // 123
"123".toLong()                          // 123L
str.toCharArray()                       // Array of chars
str.toList()                            // List of chars
```

---

### Sorting & Searching

```kotlin
val list = mutableListOf(5, 2, 8, 1, 9)

// Sorting
list.sort()                             // In-place ascending
list.sortDescending()                   // In-place descending
val sorted = list.sorted()              // New sorted list
val reversed = list.sortedDescending()  // New reversed sorted list

// Custom comparator
list.sortWith(compareBy { it })         // Ascending
list.sortWith(compareByDescending { it }) // Descending

// Complex sorting
data class Person(val name: String, val age: Int)
val people = listOf(Person("John", 30), Person("Jane", 25))

people.sortedBy { it.age }              // Sort by age
people.sortedByDescending { it.age }    // Sort by age desc
people.sortedWith(compareBy({ it.age }, { it.name })) // Multiple criteria

// Binary search (list must be sorted)
val index = list.binarySearch(5)        // Returns index or -insertionPoint - 1
val found = list.binarySearch(5) >= 0   // Check if found
```

---

### Common DSA Patterns

#### Two Pointers

```kotlin
// Find pair with sum
fun twoSum(arr: IntArray, target: Int): Pair<Int, Int>? {
    var left = 0
    var right = arr.lastIndex
    
    while (left < right) {
        val sum = arr[left] + arr[right]
        when {
            sum == target -> return Pair(left, right)
            sum < target -> left++
            else -> right--
        }
    }
    return null
}
```

#### Sliding Window

```kotlin
// Maximum sum of k consecutive elements
fun maxSum(arr: IntArray, k: Int): Int {
    var windowSum = arr.take(k).sum()
    var maxSum = windowSum
    
    for (i in k until arr.size) {
        windowSum = windowSum - arr[i - k] + arr[i]
        maxSum = maxOf(maxSum, windowSum)
    }
    return maxSum
}
```

#### Prefix Sum

```kotlin
// Range sum queries
class PrefixSum(arr: IntArray) {
    private val prefix = IntArray(arr.size + 1)
    
    init {
        for (i in arr.indices) {
            prefix[i + 1] = prefix[i] + arr[i]
        }
    }
    
    fun rangeSum(left: Int, right: Int): Int {
        return prefix[right + 1] - prefix[left]
    }
}
```

#### Binary Search

```kotlin
// Find first occurrence
fun firstOccurrence(arr: IntArray, target: Int): Int {
    var left = 0
    var right = arr.lastIndex
    var result = -1
    
    while (left <= right) {
        val mid = left + (right - left) / 2
        when {
            arr[mid] == target -> {
                result = mid
                right = mid - 1  // Continue searching left
            }
            arr[mid] < target -> left = mid + 1
            else -> right = mid - 1
        }
    }
    return result
}
```

---

### Useful Functions Reference

```kotlin
// Min/Max
minOf(a, b)                             // Minimum of two
maxOf(a, b)                             // Maximum of two
minOf(a, b, c)                          // Minimum of three
list.minOrNull()                        // Minimum in collection
list.maxOrNull()                        // Maximum in collection

// Math
abs(-5)                                 // 5
Math.pow(2.0, 3.0)                      // 8.0
Math.sqrt(16.0)                         // 4.0
Math.ceil(3.2)                          // 4.0
Math.floor(3.8)                         // 3.0

// Range
(1..10)                                 // 1 to 10 inclusive
(1 until 10)                            // 1 to 9
(10 downTo 1)                           // 10 to 1
(1..10 step 2)                          // 1, 3, 5, 7, 9

// Grouping
list.groupBy { it % 2 }                 // Group by predicate
list.associateBy { it.id }              // Map by key
list.partition { it > 5 }               // Split into two lists
list.chunked(3)                         // Split into chunks

// Combinations
list.zip(other)                         // Combine two lists
list.zipWithNext()                      // Pairs of consecutive elements
list.flatten()                          // Flatten nested lists
list.flatMap { it.toList() }            // Map and flatten

// Type conversions
str.toInt()                             // String to Int
str.toIntOrNull()                       // Safe conversion
int.toString()                          // Int to String
charArray.concatToString()              // CharArray to String
"123".toCharArray()                     // String to CharArray
list.toIntArray()                       // List to IntArray
intArray.toList()                       // IntArray to List
```

---

### Quick Tips

#### Null Handling

```kotlin
val length = str?.length ?: 0           // Elvis operator
str?.let { process(it) }                // Execute if not null
val nonNull = str!!                     // Assert non-null (throws NPE)
```

#### Range Operations

```kotlin
if (x in 1..10) { }                     // Check if in range
if (x !in 1..10) { }                    // Check if not in range
for (i in 1..n) { }                     // Iterate range
(1..n).forEach { }                      // Functional iteration
```

#### Type Conversions

```kotlin
// Number conversions
int.toLong()
long.toInt()
double.toInt()
string.toIntOrNull()

// Collection conversions
list.toSet()                            // Remove duplicates
set.toList()                            // Set to List
list.toMutableList()                    // Immutable to mutable
mutableList.toList()                    // Mutable to immutable
```

#### Common Mistakes to Avoid

```kotlin
// âŒ Modifying list while iterating
for (item in list) {
    list.remove(item)  // ConcurrentModificationException
}

// âœ… Use iterator or create new list
list.removeAll { it > 5 }
val filtered = list.filter { it <= 5 }

// âŒ Comparing with ==  for reference types without equals
if (arr1 == arr2) { }  // Compares references

// âœ… Use contentEquals for arrays
if (arr1.contentEquals(arr2)) { }

// âŒ Forgetting to handle null
val length = nullable.length  // Compilation error

// âœ… Use safe calls
val length = nullable?.length ?: 0
```

---

### DSA Time Complexities

| Operation | Array | ArrayList | LinkedList | HashSet | HashMap | TreeSet/Map |
|-----------|-------|-----------|------------|---------|---------|-------------|
| Access | O(1) | O(1) | O(n) | - | O(1) | O(log n) |
| Search | O(n) | O(n) | O(n) | O(1) | O(1) | O(log n) |
| Insert | - | O(n) | O(1) | O(1) | O(1) | O(log n) |
| Delete | - | O(n) | O(1) | O(1) | O(1) | O(log n) |
| Add (end) | - | O(1)* | O(1) | O(1) | O(1) | O(log n) |

*Amortized

---

### Quick Practice Template

```kotlin
fun main() {
    // Read input
    val n = readLine()!!.toInt()
    val arr = readLine()!!.split(" ").map { it.toInt() }.toIntArray()
    
    // Process
    val result = solve(arr, n)
    
    // Output
    println(result)
}

fun solve(arr: IntArray, n: Int): Int {
    // Your solution here
    return 0
}
```

---

**End of Quick Reference**

> **Pro Tip:** Bookmark this section for quick revision before coding interviews!

---

## References

- [Official Kotlin Documentation](https://kotlinlang.org/docs/home.html)
- [Kotlin Coroutines Guide](https://kotlinlang.org/docs/coroutines-guide.html)
- [Android Kotlin Guides](https://developer.android.com/kotlin)
- [Kotlin for Competitive Programming](https://kotlinlang.org/docs/competitive-programming.html)

---

## Summary

This guide covers:
- âœ… Kotlin Basics (1-2 hours) - Quick revision for senior engineers
- âœ… Advanced Topics (2-3 hours) - Deep dives with examples
- âœ… Common Interview Questions (1 hour) - Basic to intermediate
- âœ… Advanced Interview Questions (1-2 hours) - Senior to lead level
- âœ… Quick Reference for DSA (20 minutes) - Ultra-concise guide

**Total Reading Time:** 4-8 hours (depending on depth)

**Best Practice:** Review basics quickly, focus on advanced topics and interview questions, use DSA reference for quick lookups.

---

*Happy Learning! ðŸš€*

