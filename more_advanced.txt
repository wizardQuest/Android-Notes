### 11. Explain inline, crossinline, and noinline

**Answer:**

**inline:**
```kotlin
// Basic inline - copies lambda code to call site
inline fun measureTime(block: () -> Unit) {
    val start = System.currentTimeMillis()
    block()  // Inlined at call site
    println("Took: ${System.currentTimeMillis() - start}ms")
}

// Allows non-local returns
fun findFirst(list: List<Int>): Int? {
    list.forEach { item ->  // forEach is inline
        if (item > 5) {
            return item  // ✅ Returns from findFirst
        }
    }
    return null
}
```

**noinline:**
```kotlin
// Lambda stored or passed to non-inline function
inline fun process(
    inlineAction: () -> Unit,
    noinline storedAction: () -> Unit
) {
    inlineAction()  // Inlined
    saveForLater(storedAction)  // Not inlined - can be stored
}

fun saveForLater(action: () -> Unit) {
    // Store for later execution
}
```

**crossinline:**
```kotlin
// Lambda used in non-local context but can't use non-local returns
inline fun runAsync(crossinline action: () -> Unit) {
    thread {
        action()  // Used in different context (thread)
    }
}

fun test() {
    runAsync {
        println("Running")
        // return  // ❌ Compilation error - crossinline prevents non-local return
    }
}

// Why crossinline is needed:
inline fun problematic(action: () -> Unit) {
    thread {
        action()  // If action has return, it returns from outer function, not thread
    }
}
```

**Comparison:**

| Modifier | Inlined | Non-local returns | Can be stored | Used in other contexts |
|----------|---------|-------------------|---------------|------------------------|
| inline | ✅ | ✅ | ❌ | ❌ |
| noinline | ❌ | ❌ | ✅ | ✅ |
| crossinline | ✅ | ❌ | ❌ | ✅ |

**Real-world examples:**

```kotlin
// Standard library: let (inline, non-local returns allowed)
inline fun <T, R> T.let(block: (T) -> R): R = block(this)

// Standard library: also (crossinline, can't use non-local returns)
inline fun <T> T.also(block: (T) -> Unit): T {
    block(this)
    return this
}

// Custom: mixed lambdas
inline fun complexOperation(
    inlineTransform: (Int) -> Int,
    crossinline validate: (Int) -> Boolean,
    noinline onError: (Exception) -> Unit
) {
    try {
        val value = inlineTransform(42)
        thread {
            if (!validate(value)) {
                onError(ValidationException())
            }
        }
    } catch (e: Exception) {
        onError(e)
    }
}
```

---

### 12. How would you implement a thread-safe singleton in Kotlin?

**Answer:**

**1. Object Declaration (Recommended):**
```kotlin
// Thread-safe by default, lazy initialization
object DatabaseManager {
    private val connection by lazy {
        createConnection()
    }
    
    fun query(sql: String) = connection.execute(sql)
}
```

**2. Lazy Delegate (for class with parameters):**
```kotlin
class Repository private constructor(private val api: Api) {
    companion object {
        @Volatile
        private var instance: Repository? = null
        
        fun getInstance(api: Api): Repository {
            return instance ?: synchronized(this) {
                instance ?: Repository(api).also { instance = it }
            }
        }
    }
}
```

**3. Double-Checked Locking:**
```kotlin
class DatabaseManager private constructor(private val config: Config) {
    companion object {
        @Volatile
        private var INSTANCE: DatabaseManager? = null
        
        fun getInstance(config: Config): DatabaseManager {
            // First check (no locking)
            val currentInstance = INSTANCE
            if (currentInstance != null) {
                return currentInstance
            }
            
            // Second check (with locking)
            return synchronized(this) {
                val newInstance = INSTANCE
                if (newInstance != null) {
                    newInstance
                } else {
                    DatabaseManager(config).also {
                        INSTANCE = it
                    }
                }
            }
        }
    }
}
```

**4. Lazy Delegate (thread-safe):**
```kotlin
class Repository private constructor(private val database: Database) {
    companion object {
        private var database: Database? = null
        
        val instance: Repository by lazy(LazyThreadSafetyMode.SYNCHRONIZED) {
            Repository(database ?: throw IllegalStateException("Initialize first"))
        }
        
        fun initialize(db: Database) {
            database = db
        }
    }
}

// Usage
Repository.initialize(databaseInstance)
val repo = Repository.instance
```

**5. Holder Pattern:**
```kotlin
class CacheManager private constructor() {
    companion object {
        fun getInstance(): CacheManager = Holder.instance
    }
    
    private object Holder {
        val instance = CacheManager()
    }
}
```

**Testing Considerations:**

```kotlin
// For testability - use interface + DI
interface UserRepository {
    fun getUsers(): List<User>
}

class UserRepositoryImpl(private val api: Api) : UserRepository {
    override fun getUsers() = api.fetchUsers()
}

// In production: use Dagger/Hilt
@Singleton
class UserRepositoryImpl @Inject constructor(
    private val api: Api
) : UserRepository

// In tests: easily mock
val mockRepo = mockk<UserRepository>()
```

**Best Practices:**
- Prefer `object` for simple singletons
- Use DI framework (Dagger, Hilt) for complex apps
- Avoid singletons when possible (hard to test)
- Use `@Volatile` with double-checked locking
- Consider lifecycle-scoped instances instead

---

### 13. How does Kotlin handle SAM (Single Abstract Method) conversions?

**Answer:**

SAM conversion allows using lambdas where functional interfaces are expected.

**Java Interfaces:**

```kotlin
// Java interface
public interface OnClickListener {
    void onClick(View view);
}

// Kotlin usage - SAM conversion
button.setOnClickListener { view ->
    println("Clicked!")
}

// Equivalent to:
button.setOnClickListener(object : OnClickListener {
    override fun onClick(view: View) {
        println("Clicked!")
    }
})
```

**Kotlin fun interfaces (1.4+):**

```kotlin
// Kotlin functional interface
fun interface StringProcessor {
    fun process(input: String): String
}

// SAM conversion works
fun transform(input: String, processor: StringProcessor): String {
    return processor.process(input)
}

// Lambda usage
val result = transform("hello") { it.uppercase() }

// Multiple function calls - separate objects created
transform("a") { it.uppercase() }
transform("b") { it.uppercase() }
```

**Limitations:**

```kotlin
// ❌ SAM conversion doesn't work for Kotlin interfaces (pre-1.4)
interface Processor {
    fun process(input: String): String
}

fun transform(input: String, processor: Processor): String {
    return processor.process(input)
}

// Must use object expression
transform("hello", object : Processor {
    override fun process(input: String) = input.uppercase()
})

// ✅ Works with fun interface
fun interface Processor {
    fun process(input: String): String
}

transform("hello") { it.uppercase() }
```

**Performance Considerations:**

```kotlin
// Lambda creates new object each time
repeat(1000) {
    button.setOnClickListener { view ->
        println("Clicked!")
    }
}
// Creates 1000 listener objects

// Reuse same listener
val listener = View.OnClickListener { view ->
    println("Clicked!")
}
repeat(1000) {
    button.setOnClickListener(listener)
}
// Creates 1 listener object
```

**Suspend SAM:**

```kotlin
// Suspend functional interface
fun interface SuspendProcessor {
    suspend fun process(input: String): String
}

suspend fun transform(input: String, processor: SuspendProcessor): String {
    return processor.process(input)
}

// Usage
lifecycleScope.launch {
    val result = transform("hello") { input ->
        delay(100)
        input.uppercase()
    }
}
```

---

### 14. What is the difference between internal and private visibility?

**Answer:**

**private:**
- Visible only within the same file/class
- Most restrictive visibility

**internal:**
- Visible within the same module
- Module = Gradle module, Maven project, IntelliJ module

```kotlin
// File: User.kt
private class InternalUser(val id: String)  // Visible only in this file

internal class PublicUser(val id: String)   // Visible in same module

class UserManager {
    private val secret = "secret"           // Only in UserManager
    internal val apiKey = "key"             // Visible in module
    
    private fun encrypt() { }               // Only in UserManager
    internal fun authenticate() { }         // Visible in module
}

// File: Main.kt (same module)
fun test() {
    // val user = InternalUser("123")       // ❌ Not visible
    val user = PublicUser("123")            // ✅ Visible (same module)
    
    val manager = UserManager()
    // manager.secret                       // ❌ Not visible
    manager.apiKey                          // ✅ Visible (same module)
}

// Different module
fun testFromOtherModule() {
    // val user = PublicUser("123")         // ❌ Not visible (different module)
}
```

**Use Cases:**

```kotlin
// private - implementation details
class Repository {
    private val cache = mutableMapOf<String, User>()
    
    private fun validateUser(user: User): Boolean {
        return user.email.contains("@")
    }
    
    fun saveUser(user: User) {
        if (validateUser(user)) {
            cache[user.id] = user
        }
    }
}

// internal - module API (not public)
internal class NetworkClient {
    internal fun makeRequest(url: String): Response {
        // Implementation
    }
}

// Used across module, but not exposed to external consumers
internal object Analytics {
    internal fun logEvent(event: String) {
        // Implementation
    }
}
```

**Module Structure:**

```
app (module)
├── User.kt
│   internal class User            // Visible in app module
│   private class UserImpl         // Visible only in User.kt
│
library (module)
├── Api.kt
│   internal class ApiClient       // Visible in library module only
│   private fun connect()          // Visible only in Api.kt
```

**Visibility Summary:**

| Modifier | Class/Top-level | Class member |
|----------|-----------------|--------------|
| private | Same file | Same class |
| internal | Same module | Same module |
| protected | N/A | Same class + subclasses |
| public | Everywhere | Everywhere |

---

### 15. Explain @JvmStatic, @JvmOverloads, @JvmField

**Answer:**

These annotations improve Java interoperability.

**@JvmStatic:**

```kotlin
// Kotlin
class User {
    companion object {
        @JvmStatic
        fun create(name: String) = User(name)
        
        fun validate(name: String) = name.isNotEmpty()
    }
}

object Logger {
    @JvmStatic
    fun log(message: String) {
        println(message)
    }
}
```

```java
// Java usage
// With @JvmStatic
User user = User.create("John");        // ✅ Static method
Logger.log("Message");                  // ✅ Static method

// Without @JvmStatic
boolean valid = User.Companion.validate("John");  // ❌ Must use Companion
```

**@JvmOverloads:**

```kotlin
// Kotlin - generates multiple constructors/methods
class User @JvmOverloads constructor(
    val name: String,
    val age: Int = 0,
    val email: String = ""
)

@JvmOverloads
fun greet(name: String, greeting: String = "Hello") {
    println("$greeting, $name")
}
```

```java
// Java usage - multiple overloads generated
User user1 = new User("John");
User user2 = new User("John", 30);
User user3 = new User("John", 30, "john@example.com");

greet("John");                    // Uses default greeting
greet("John", "Hi");              // Custom greeting
```

**Generated Java code:**
```java
public User(String name) {
    this(name, 0, "");
}

public User(String name, int age) {
    this(name, age, "");
}

public User(String name, int age, String email) {
    // Full constructor
}
```

**@JvmField:**

```kotlin
// Kotlin
class Config {
    @JvmField
    val timeout = 5000
    
    val retries = 3  // Without @JvmField
    
    companion object {
        @JvmField
        val MAX_SIZE = 1000
    }
}
```

```java
// Java usage
// With @JvmField - direct field access
int timeout = config.timeout;           // ✅ Direct field access
int maxSize = Config.MAX_SIZE;          // ✅ Static field

// Without @JvmField - must use getter
int retries = config.getRetries();      // ❌ Must use getter
```

**Real-World Example:**

```kotlin
// Kotlin Library
object Constants {
    @JvmField
    val API_URL = "https://api.example.com"
    
    @JvmStatic
    fun getVersion() = "1.0.0"
}

class Builder @JvmOverloads constructor(
    val name: String,
    val age: Int = 0,
    val email: String = ""
) {
    companion object {
        @JvmStatic
        fun create(name: String): Builder {
            return Builder(name)
        }
    }
}
```

```java
// Java Consumer
String url = Constants.API_URL;              // Direct access
String version = Constants.getVersion();     // Static method

Builder builder1 = new Builder("John");      // Default parameters
Builder builder2 = Builder.create("Jane");   // Static factory
```

**When to Use:**
- **@JvmStatic**: Methods that should be static in Java
- **@JvmOverloads**: Functions/constructors with default parameters used from Java
- **@JvmField**: Properties that should be fields (not getters) in Java

---

### 16. How does Kotlin handle checked exceptions differently than Java?

**Answer:**

Kotlin doesn't have checked exceptions - all exceptions are unchecked.

**Java:**
```java
// Java - must declare or catch checked exceptions
public String readFile() throws IOException {  // Must declare
    return Files.readString(Path.of("file.txt"));
}

public void process() {
    try {
        readFile();  // Must catch or declare
    } catch (IOException e) {
        // Handle
    }
}
```

**Kotlin:**
```kotlin
// Kotlin - no checked exceptions
fun readFile(): String {
    return File("file.txt").readText()  // May throw IOException, no declaration needed
}

fun process() {
    readFile()  // No forced try-catch
}

// Can still catch if needed
fun processSafely() {
    try {
        readFile()
    } catch (e: IOException) {
        // Handle
    }
}
```

**Interop with Java:**

```kotlin
// Kotlin function called from Java
fun save(data: String) {
    throw IOException("Failed")  // Unchecked in Kotlin
}
```

```java
// Java code
public void caller() {
    save("data");  // Java compiler doesn't force try-catch
}
```

**@Throws Annotation:**

```kotlin
// Tell Java about potential exceptions
@Throws(IOException::class, SQLException::class)
fun saveToDatabase(data: String) {
    // Implementation
}
```

```java
// Java code - now aware of exceptions
public void caller() {
    try {
        saveToDatabase("data");  // Java compiler now requires handling
    } catch (IOException | SQLException e) {
        // Handle
    }
}
```

**Rationale:**

```kotlin
// Java's checked exceptions often lead to:

// 1. Empty catch blocks
try {
    operation();
} catch (Exception e) {
    // Ignored
}

// 2. Wrapped exceptions
try {
    operation();
} catch (CheckedException e) {
    throw new RuntimeException(e);  // Just wrapping
}

// 3. Large try-catch blocks
try {
    operation1();
    operation2();
    operation3();
} catch (Exception1 | Exception2 | Exception3 e) {
    // Handle all
}

// Kotlin's approach: handle exceptions when meaningful
fun process() {
    val data = readFile()  // Crash if fails - expected behavior
    processData(data)
}

fun processWithRecovery() {
    val data = try {
        readFile()
    } catch (e: IOException) {
        getDefaultData()  // Meaningful recovery
    }
    processData(data)
}
```

**Best Practices:**

```kotlin
// 1. Use Result type for expected failures
fun loadData(): Result<Data> {
    return try {
        Result.success(fetchData())
    } catch (e: Exception) {
        Result.failure(e)
    }
}

// 2. Use sealed classes for errors
sealed class DataResult {
    data class Success(val data: Data) : DataResult()
    data class Error(val exception: Exception) : DataResult()
}

// 3. Document exceptions in KDoc
/**
 * Loads user data from the network.
 * @throws IOException if network request fails
 * @throws JsonException if parsing fails
 */
fun loadUser(): User {
    // Implementation
}
```

---

### 17. Explain the difference between coroutineScope and CoroutineScope

**Answer:**

**coroutineScope (lowercase) - Suspend function:**

```kotlin
// Creates a scope and suspends until all children complete
suspend fun loadData() = coroutineScope {
    val user = async { fetchUser() }
    val posts = async { fetchPosts() }
    
    UserData(user.await(), posts.await())
}  // Suspends until all async complete

// Used for parallel decomposition
suspend fun processMultiple() = coroutineScope {
    launch { process1() }
    launch { process2() }
    launch { process3() }
}  // Returns when all complete
```

**CoroutineScope (uppercase) - Interface:**

```kotlin
// Creates a long-lived scope
class Repository {
    private val scope = CoroutineScope(
        SupervisorJob() + Dispatchers.IO
    )
    
    fun loadData() {
        scope.launch {
            // Coroutine runs in scope
        }
    }
    
    fun cleanup() {
        scope.cancel()  // Cancel all coroutines
    }
}
```

**Key Differences:**

| Feature | coroutineScope | CoroutineScope |
|---------|----------------|----------------|
| Type | Suspend function | Interface |
| Lifetime | Until children complete | Until manually cancelled |
| Usage | Parallel decomposition | Long-lived operations |
| Exception handling | Propagates to caller | Needs handler |
| When to use | Inside suspend functions | Class-level scope |

**Practical Examples:**

```kotlin
// coroutineScope - structured concurrency
suspend fun fetchAllData(): Data = coroutineScope {
    val users = async { api.getUsers() }
    val posts = async { api.getPosts() }
    val comments = async { api.getComments() }
    
    Data(
        users = users.await(),
        posts = posts.await(),
        comments = comments.await()
    )
}  // If any fails, all are cancelled

// CoroutineScope - lifecycle-bound
class ViewModel : ViewModel() {
    private val viewModelScope = CoroutineScope(
        SupervisorJob() + Dispatchers.Main
    )
    
    fun loadData() {
        viewModelScope.launch {
            // Long-running work
        }
    }
    
    override fun onCleared() {
        viewModelScope.cancel()
    }
}

// Combining both
class Repository(private val scope: CoroutineScope) {
    fun getData() = scope.launch {
        // Parallel decomposition within scope
        val result = coroutineScope {
            val a = async { fetchA() }
            val b = async { fetchB() }
            combine(a.await(), b.await())
        }
        processResult(result)
    }
}
```

**Exception Handling:**

```kotlin
// coroutineScope - exception cancels all siblings
suspend fun process() = coroutineScope {
    launch { task1() }  // If this fails
    launch { task2() }  // This is cancelled
    launch { task3() }  // This is cancelled too
}

// supervisorScope - exceptions don't cancel siblings
suspend fun processIndependent() = supervisorScope {
    launch { task1() }  // If this fails
    launch { task2() }  // This continues
    launch { task3() }  // This continues too
}

// CoroutineScope with SupervisorJob
class Worker {
    private val scope = CoroutineScope(SupervisorJob())
    
    fun start() {
        scope.launch { task1() }  // Independent
        scope.launch { task2() }  // Independent
    }
}
```

---

### 18. Explain the difference between tailrec and regular recursion with performance implications

**Answer:**

**Regular Recursion:**

```kotlin
// Stack frames accumulate
fun factorial(n: Int): Long {
    return if (n <= 1) 1 
    else n * factorial(n - 1)
}

// Stack trace for factorial(4):
// factorial(4) = 4 * factorial(3)
//   factorial(3) = 3 * factorial(2)
//     factorial(2) = 2 * factorial(1)
//       factorial(1) = 1

// Memory: O(n) stack frames
// factorial(10000)  // ❌ StackOverflowError
```

**Tail Recursion:**

```kotlin
// Compiler optimizes to loop
tailrec fun factorial(n: Long, accumulator: Long = 1): Long {
    return if (n <= 1) accumulator
    else factorial(n - 1, n * accumulator)
}

// Compiled to (approximately):
fun factorial(n: Long, accumulator: Long = 1): Long {
    var currentN = n
    var currentAcc = accumulator
    while (currentN > 1) {
        currentAcc = currentN * currentAcc
        currentN = currentN - 1
    }
    return currentAcc
}

// Memory: O(1) - no stack frames
// factorial(10000)  // ✅ Works
```

**Performance Comparison:**

```kotlin
// Benchmark
fun benchmarkFactorial() {
    // Regular recursion
    val time1 = measureTimeMillis {
        regularFactorial(5000)  // May crash
    }
    
    // Tail recursion
    val time2 = measureTimeMillis {
        tailrecFactorial(5000)  // Fast and safe
    }
    
    println("Regular: $time1ms")
    println("Tailrec: $time2ms (typically faster)")
}
```

**Requirements for tailrec:**

```kotlin
// ✅ Valid - recursive call is last operation
tailrec fun sum(n: Int, acc: Int = 0): Int {
    return if (n == 0) acc else sum(n - 1, acc + n)
}

// ❌ Invalid - operation after recursive call
fun factorial(n: Int): Int {
    return if (n <= 1) 1 
    else n * factorial(n - 1)  // Multiplication happens after call
}

// ❌ Invalid - multiple recursive calls
fun fibonacci(n: Int): Int {
    return if (n <= 1) n
    else fibonacci(n - 1) + fibonacci(n - 2)  // Two calls
}
```

**Converting to Tail Recursion:**

```kotlin
// Regular → Tailrec: Fibonacci
// Regular (exponential time)
fun fibonacci(n: Int): Int {
    return if (n <= 1) n
    else fibonacci(n - 1) + fibonacci(n - 2)
}

// Tailrec (linear time)
tailrec fun fibonacci(n: Int, a: Long = 0, b: Long = 1): Long {
    return when (n) {
        0 -> a
        1 -> b
        else -> fibonacci(n - 1, b, a + b)
    }
}

// Regular → Tailrec: List sum
// Regular
fun sum(list: List<Int>): Int {
    return if (list.isEmpty()) 0
    else list.first() + sum(list.drop(1))
}

// Tailrec
tailrec fun sum(list: List<Int>, acc: Int = 0): Int {
    return if (list.isEmpty()) acc
    else sum(list.drop(1), acc + list.first())
}
```

**Performance Metrics:**

| Aspect | Regular Recursion | Tail Recursion |
|--------|-------------------|----------------|
| Stack space | O(n) | O(1) |
| Speed | Slower (function calls) | Faster (loop) |
| Max depth | ~10,000 calls | Unlimited |
| Debugging | Easier (stack trace) | Harder (loop) |

---


